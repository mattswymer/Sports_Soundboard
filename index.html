<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sports Soundboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/wavesurfer.js@7"></script>
    <style>
      /* Using Inter as a clean, modern font */
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');

      /* Base styles for a dark theme */
      body {
        background-color: #111827; /* Darker gray for more contrast */
        color: #f9fafb;
        font-family: 'Inter', sans-serif;
        padding: 1.5rem;
      }

      /* Custom styles for the toggle switch for a cleaner look */
      .toggle {
        position: relative;
        width: 42px;
        height: 24px;
      }
      .toggle input {
        display: none;
      }
      .toggle .track {
        position: absolute;
        inset: 0;
        border-radius: 9999px;
        background: #4b5563;
        transition: background-color 0.2s ease-in-out;
      }
      .toggle .thumb {
        position: absolute;
        top: 2px;
        left: 2px;
        width: 20px;
        height: 20px;
        background: #ffffff;
        border-radius: 9999px;
        transition: transform 0.2s ease-in-out;
      }
      .toggle input:checked + .track {
        background: #22c55e;
      }
      .toggle input:checked + .track .thumb {
        transform: translateX(18px);
      }

      /* Styling for play/pause/stop buttons (Compact) */
      .btn-playpause, .btn-stop {
        color: white;
        border-radius: 9999px;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
      }
      .btn-playpause { background-color: #22c55e; }
      .btn-stop { background-color: #ef4444; }

      /* Allow sound card titles to wrap */
      .sound-card .title {
        white-space: normal;
      }

      /* Class for items being dragged */
      .dragging {
        opacity: 0.5;
        border: 2px solid #3b82f6;
      }

      /* Waveform styling (Compact) */
      .waveform-container {
        height: 40px;
        cursor: pointer;
      }

      /* Drop zone styling */
      .drop-zone {
        transition: all 0.2s ease-in-out;
        min-height: 200px; /* Base height for drop zones */
      }
      .drop-zone.drag-over {
        border-color: #3b82f6 !important;
        background-color: rgba(59, 130, 246, 0.1) !important;
      }
      /* Hide the placeholder text when the column has items */
      .drop-zone.has-items .drop-area {
        display: none;
      }

      /* Editable section title styling */
      .section-title {
        outline: none;
        border-radius: 0.5rem;
        padding: 0.25rem 0.5rem;
        margin: -0.25rem -0.5rem; /* Offset padding */
        transition: background-color 0.2s;
      }
      .section-title:focus {
        background-color: #374151; /* bg-gray-700 */
        box-shadow: 0 0 0 2px #3b82f6; /* focus ring */
      }

      /* Modal styles */
      .modal-overlay {
        position: fixed;
        inset: 0;
        background-color: rgba(0, 0, 0, 0.75);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.2s ease-in-out;
        pointer-events: none;
      }
      .modal-overlay.visible {
        opacity: 1;
        pointer-events: auto;
      }
      .modal-content {
        background-color: #1f2937;
        padding: 2rem;
        border-radius: 1rem;
        color: white;
        max-width: 90%;
        width: 500px;
        transform: scale(0.95);
        transition: transform 0.2s ease-in-out;
        max-height: 85vh; /* MOBILE FIX: Limit height */
        overflow-y: auto; /* MOBILE FIX: Enable scrolling */
      }
      .modal-overlay.visible .modal-content {
        transform: scale(1);
      }

      /* Recording indicator animation */
      .recording-pulse {
          background-color: #ef4444;
          animation: pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
      }
      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
      }
    </style>
</head>
<body class="bg-gray-900 text-white p-6">

  <header class="flex flex-col md:flex-row items-center justify-between mb-6 gap-4">
    <h1 class="text-3xl font-bold flex items-center gap-3">
      Sports Soundboard
    </h1>
    <div id="donationLinks" class="flex items-center gap-2 text-sm text-gray-400">
      Like this app?
      <a href="https://www.paypal.me/mattswymer84" target="_blank" title="PayPal">
        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/0e/PayPal_2024_%28Icon%29.svg/250px-PayPal_2024_%28Icon%29.svg.png" alt="PayPal" class="h-6 w-auto" />
      </a>
      <a href="https://venmo.com/mattswymer" target="_blank" title="Venmo">
        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/84/Venmo_logo.png/1200px-Venmo_logo.png" alt="Venmo" class="h-6 w-auto" />
      </a>
    </div>
    <div class="flex flex-wrap items-center gap-6">
      <div class="flex items-center gap-3">
        <label for="fadeInSlider" class="text-sm shrink-0">Fade In (s)</label>
        <input id="fadeInSlider" type="range" min="0" max="8" step="0.1" value="2.0" class="w-24 md:w-40" />
        <span id="fadeInVal" class="w-8 text-right font-mono">2.0</span>
      </div>
      <div class="flex items-center gap-3">
        <label for="fadeOutSlider" class="text-sm shrink-0">Fade Out (s)</label>
        <input id="fadeOutSlider" type="range" min="0" max="8" step="0.1" value="2.0" class="w-24 md:w-40" />
        <span id="fadeOutVal" class="w-8 text-right font-mono">2.0</span>
      </div>
      <button id="fadeAllBtn" class="bg-red-600 hover:bg-red-500 active:bg-red-700 px-4 py-2 rounded-xl font-semibold shadow transition-transform active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed">Fade Out All</button>
      <button id="helpBtn" class="bg-gray-600 hover:bg-gray-500 w-10 h-10 rounded-full text-xl font-bold flex items-center justify-center transition-transform active:scale-95" title="Help">?</button>
    </div>
  </header>

  <section class="mb-6">
    <div class="bg-gray-800 border border-gray-700 rounded-2xl p-4">
      <div class="grid grid-cols-1 lg:grid-cols-12 gap-4 items-center">
        <div class="lg:col-span-6">
          <label for="ttsText" class="sr-only">Text to generate speech from</label>
          <input id="ttsText" type="text" placeholder="Now batting, number 42, Jackie Robinson..." class="w-full bg-gray-900 border border-gray-600 rounded-xl px-4 py-2 text-white placeholder-gray-400 focus:border-blue-500 focus:outline-none" />
        </div>
        <div class="lg:col-span-5 flex flex-col sm:flex-row gap-2">
          <label for="voiceSelect" class="sr-only">Select voice</label>
          <select id="voiceSelect" class="bg-gray-900 border border-gray-600 rounded-xl px-3 py-2 text-white focus:border-blue-500 focus:outline-none text-sm min-w-0 flex-1">
            <option value="">Loading voices...</option>
          </select>
          <div class="flex gap-2 shrink-0">
            <button id="previewBtn" class="bg-blue-600 hover:bg-blue-500 active:bg-blue-700 px-3 py-2 rounded-xl text-sm font-semibold shadow transition-colors whitespace-nowrap active:scale-95">üîä Preview</button>
            <button id="generateBtn" class="bg-green-600 hover:bg-green-500 active:bg-green-700 px-3 py-2 rounded-xl text-sm font-semibold shadow transition-colors whitespace-nowrap active:scale-95">‚ûï Add to First Section</button>
          </div>
        </div>
        <div class="lg:col-span-1 flex justify-center lg:justify-end">
          <div class="relative">
            <button id="recordBtn" class="w-14 h-14 bg-gray-700 hover:bg-gray-600 border-2 border-gray-600 rounded-full flex items-center justify-center text-xl transition-all duration-200 select-none active:scale-95" title="Hold to record">üéôÔ∏è</button>
            <div id="recordingTooltip" class="absolute -top-12 left-1/2 transform -translate-x-1/2 bg-gray-900 text-white text-xs px-2 py-1 rounded-lg opacity-0 pointer-events-none transition-opacity duration-200 whitespace-nowrap z-10">Hold to record</div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- This main grid will be populated dynamically with sections -->
  <main id="soundboard-grid" class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6">
    <!-- Sections will be inserted here by JavaScript -->
  </main>

  <footer class="mt-6">
      <button id="addSectionBtn" class="w-full bg-gray-700 hover:bg-gray-600 text-gray-300 font-semibold py-3 rounded-xl transition-colors active:scale-95">Ôºã Add New Section</button>
  </footer>


  <div id="alertModal" class="modal-overlay">
    <div class="modal-content">
      <h3 class="text-xl font-bold mb-4">Message</h3>
      <p id="alertMessage"></p>
      <div class="mt-6 text-right">
        <button id="alertModalCloseBtn" class="bg-blue-600 hover:bg-blue-500 active:bg-blue-700 px-4 py-2 rounded-xl font-semibold shadow active:scale-95">OK</button>
      </div>
    </div>
  </div>

  <div id="helpModal" class="modal-overlay">
      <div class="modal-content">
          <h3 class="text-2xl font-bold mb-4">Welcome to Sports Soundboard!</h3>
          <div class="space-y-4 text-gray-300">
              <p>This app is designed for playing audio at live events directly from your device, ensuring reliability even with poor cell service or crowded networks.</p>

              <div>
                  <h4 class="font-semibold text-lg mb-2 text-white">Getting Started</h4>
                  <ol class="list-decimal list-inside space-y-2">
                      <li><strong>Create Your Layout:</strong> Start by adding sections using the "Ôºã Add New Section" button. Click on a section's title (e.g., "New Section") to rename it to whatever you like, such as "Walk-up Music" or "Player Announcements".</li>
                      <li>
                          <strong>Add Your Sounds:</strong> You have three ways to add audio to a section:
                          <ul class="list-disc list-inside ml-4 mt-1">
                              <li><strong>Upload:</strong> Use the "Ôºã Add Sound / Import" button in each section or drag and drop your audio files directly into any section.</li>
                              <li><strong>Record:</strong> Click and hold the üéôÔ∏è button to record a quick clip. It will be added to the *first* section.</li>
                              <li><strong>Text-to-Speech (TTS):</strong> Type a phrase, choose a voice, and click "Add". This will also add the sound to the *first* section.</li>
                          </ul>
                      </li>
                       <li><strong>Organize:</strong> You can drag and drop any sound card between your sections to organize them perfectly for your event.</li>
                      <li><strong>Customize Each Sound:</strong> Every sound card has its own controls to set a custom <strong>Start Time</strong>, adjust the <strong>Volume</strong>, and toggle <strong>Fade In</strong> or <strong>Fade Out</strong> effects.</li>
                  </ol>
              </div>

              <div>
                  <h4 class="font-semibold text-lg mb-2 text-white">Good to Know</h4>
                  <ul class="list-disc list-inside space-y-2">
                      <li><strong>Everything is Saved Locally:</strong> All your sounds and your custom section layout are automatically saved in your browser, so your complete soundboard will be ready the next time you open the app on this device.</li>
                  </ul>
              </div>
          </div>
          <div class="mt-6 text-right">
              <button id="helpModalCloseBtn" class="bg-blue-600 hover:bg-blue-500 active:bg-blue-700 px-4 py-2 rounded-xl font-semibold shadow active:scale-95">Got It</button>
          </div>
      </div>
  </div>

<script>
document.addEventListener('DOMContentLoaded', () => {

  // ===================================================================
  // A. CONFIGURATION & STATE VARIABLES
  // ===================================================================

  // --- Constants ---
  const DB_NAME = 'soundboardDB_v2'; // Upped version for new structure
  const DB_VERSION = 1;
  const SOUNDS_STORE = 'sounds';
  const SECTIONS_STORE = 'sections';
  const SETTINGS_KEY = 'sb_settings_v1';

  // --- DOM Element References ---
  const $ = (sel, root = document) => root.querySelector(sel);
  const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));

  const soundboardGrid = $('#soundboard-grid');
  const addSectionBtn = $('#addSectionBtn');
  const fadeInSlider = $('#fadeInSlider');
  const fadeOutSlider = $('#fadeOutSlider');
  const fadeInVal = $('#fadeInVal');
  const fadeOutVal = $('#fadeOutVal');
  const fadeAllBtn = $('#fadeAllBtn');
  const helpBtn = $('#helpBtn');
  const ttsText = $('#ttsText');
  const voiceSelect = $('#voiceSelect');
  const previewBtn = $('#previewBtn');
  const generateBtn = $('#generateBtn');
  const recordBtn = $('#recordBtn');
  const recordingTooltip = $('#recordingTooltip');

  // Modals
  const alertModal = $('#alertModal');
  const alertMessage = $('#alertMessage');
  const alertModalCloseBtn = $('#alertModalCloseBtn');
  const helpModal = $('#helpModal');
  const helpModalCloseBtn = $('#helpModalCloseBtn');

  // --- Application State ---
  let fadeInTime = 2.0;
  let fadeOutTime = 2.0;
  let sections = []; // Will hold our section objects {id, name}
  const activeAudios = new Map(); // Maps card element -> wavesurfer instance
  const activeUtterances = new Set(); // Stores active TTS utterances
  let mediaRecorder;
  let audioChunks = [];
  let isRecording = false;
  let microphoneStream = null;


  // ===================================================================
  // B. CORE MODULES & UTILITY FUNCTIONS
  // ===================================================================

  /**
   * Formats seconds into a m:ss time string.
   * @param {number} sec - The time in seconds.
   * @returns {string} The formatted time string.
   */
  const formatTime = (sec) => {
    if (isNaN(sec) || !isFinite(sec)) return '0:00';
    const m = Math.floor(sec / 60);
    const s = Math.floor(sec % 60).toString().padStart(2, '0');
    return `${m}:${s}`;
  };

  /**
   * Displays a message in the alert modal.
   * @param {string} message - The message to display.
   */
  const showMessage = (message) => {
    alertMessage.textContent = message;
    alertModal.classList.add('visible');
  };

  // --- IndexedDB Wrapper ---
  const idb = {
    db: null,
    open: async () => {
        if (idb.db) return idb.db;
        return new Promise((resolve, reject) => {
            const req = indexedDB.open(DB_NAME, DB_VERSION);
            req.onupgradeneeded = e => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains(SOUNDS_STORE)) {
                    db.createObjectStore(SOUNDS_STORE);
                }
                if (!db.objectStoreNames.contains(SECTIONS_STORE)) {
                    db.createObjectStore(SECTIONS_STORE);
                }
            };
            req.onsuccess = e => {
                idb.db = e.target.result;
                resolve(idb.db);
            };
            req.onerror = e => reject(e.target.error);
        });
    },
    get: async (storeName, key) => {
      const db = await idb.open();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(storeName, 'readonly');
        const req = tx.objectStore(storeName).get(key);
        req.onsuccess = () => resolve(req.result);
        req.onerror = e => reject(e.target.error);
      });
    },
    set: async (storeName, key, value) => {
      const db = await idb.open();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(storeName, 'readwrite');
        tx.objectStore(storeName).put(value, key);
        tx.oncomplete = () => resolve();
        tx.onerror = e => reject(e.target.error);
      });
    },
    getAll: async (storeName) => {
      const db = await idb.open();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(storeName, 'readonly');
        const req = tx.objectStore(storeName).getAll();
        req.onsuccess = () => resolve(req.result);
        req.onerror = e => reject(e.target.error);
      });
    },
    delete: async (storeName, key) => {
      const db = await idb.open();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(storeName, 'readwrite');
        tx.objectStore(storeName).delete(key);
        tx.oncomplete = () => resolve();
        tx.onerror = e => reject(e.target.error);
      });
    }
  };

  // --- Settings Management (LocalStorage) ---
  const saveSettings = () => localStorage.setItem(SETTINGS_KEY, JSON.stringify({ fadeIn: fadeInTime, fadeOut: fadeOutTime }));
  const loadSettings = () => JSON.parse(localStorage.getItem(SETTINGS_KEY) || '{}');


  // ===================================================================
  // C. UI & COMPONENT CREATION
  // ===================================================================

  /**
   * Creates a reusable toggle switch component.
   * @param {string} labelText - The text label for the toggle.
   * @returns {{wrap: HTMLElement, input: HTMLInputElement}}
   */
  const createToggle = (labelText) => {
    const wrap = document.createElement('label');
    wrap.className = 'flex items-center gap-2 text-xs select-none cursor-pointer';
    wrap.innerHTML = `
      <span>${labelText}</span>
      <span class="toggle inline-block">
        <input type="checkbox" checked />
        <span class="track"><span class="thumb"></span></span>
      </span>`;
    return { wrap, input: wrap.querySelector('input') };
  };

  /**
   * Creates a sound card element. Does not handle persistence.
   * @param {object} cardData - Data for the card (name, blob, idbKey, etc.).
   * @returns {Promise<HTMLElement>} The created card element.
   */
  const createCardElement = async (cardData) => {
    const { name, blob, idbKey, text, voiceName, volume = 1.0, startTime = 0 } = cardData;
    const card = document.createElement('div');
    card.className = 'sound-card group/card bg-gray-800 border border-gray-700 rounded-2xl p-2 mb-2 shadow flex flex-col gap-2';
    card.draggable = true;
    card.dataset.idbKey = idbKey || null;
    card.dataset.type = text ? 'tts' : 'audio';

    const header = document.createElement('div');
    header.className = 'flex items-center gap-2';
    header.innerHTML = `
      <div class="text-gray-500 cursor-grab select-none pt-1">‚ãÆ‚ãÆ</div>
      <button class="btn-playpause shrink-0 transition-transform active:scale-95" aria-label="Play">‚ñ∂</button>
      <button class="btn-stop shrink-0 transition-transform active:scale-95" aria-label="Stop">‚èπ</button>
      <div class="title font-semibold flex-1 min-w-0" title="${name}">${name}</div>
      <button class="edit-btn text-gray-300 hover:text-white transition-transform active:scale-95 shrink-0" title="Rename">‚úé</button>
      <button class="del-btn text-gray-300 hover:text-red-400 transition-transform active:scale-95 shrink-0" title="Delete">‚úñ</button>
    `;
    card.appendChild(header);

    const playBtn = $('.btn-playpause', header);
    const stopBtn = $('.btn-stop', header);
    const titleEl = $('.title', header);
    const editBtn = $('.edit-btn', header);
    const delBtn = $('.del-btn', header);

    if (card.dataset.type === 'audio') {
        const details = document.createElement('div');
        details.className = 'pl-10 flex flex-col gap-2';

        const fadeInToggle = createToggle('Fade In');
        const fadeOutToggle = createToggle('Fade Out');
        const togglesWrap = document.createElement('div');
        togglesWrap.className = 'flex items-center gap-4';
        togglesWrap.append(fadeInToggle.wrap, fadeOutToggle.wrap);

        const controlsWrap = document.createElement('div');
        controlsWrap.className = 'flex items-center gap-4';

        const volumeWrap = document.createElement('div');
        volumeWrap.className = 'flex items-center gap-2 flex-1';
        volumeWrap.innerHTML = `<span class="text-xs w-12">Volume</span><input type="range" min="0" max="1" step="0.01" value="${volume}" class="w-full">`;
        const volumeSlider = $('input', volumeWrap);

        const startTimeWrap = document.createElement('div');
        startTimeWrap.className = 'flex items-center gap-2';
        startTimeWrap.innerHTML = `<label class="text-xs" for="startTime-${idbKey}">Start (s)</label><input type="number" id="startTime-${idbKey}" value="${startTime}" min="0" step="0.1" class="w-20 bg-gray-700 rounded px-2 py-1 text-xs">`;
        const startTimeInput = $('input', startTimeWrap);

        controlsWrap.append(volumeWrap, startTimeWrap);

        const progressContainer = document.createElement('div');
        progressContainer.innerHTML = `
            <div class="waveform-container bg-gray-700/50 rounded-lg" role="button" tabindex="0" aria-label="Seek audio position"></div>
            <div class="flex justify-between text-xs text-gray-400 mt-0.5 font-mono">
            <span class="cur">0:00</span>
            <span class="dur">0:00</span>
            </div>`;
        const waveformEl = $('.waveform-container', progressContainer);
        const curLbl = $('.cur', progressContainer);
        const durLbl = $('.dur', progressContainer);

        details.append(togglesWrap, controlsWrap, progressContainer);
        card.appendChild(details);

        const wavesurfer = WaveSurfer.create({
            container: waveformEl, waveColor: '#6b7280', progressColor: '#3b82f6', height: 40,
            cursorWidth: 1, cursorColor: '#f87171', barWidth: 2, barRadius: 2, url: URL.createObjectURL(blob),
        });
        activeAudios.set(card, wavesurfer);

        wavesurfer.on('ready', (duration) => { durLbl.textContent = formatTime(duration); wavesurfer.setVolume(volumeSlider.value); });
        wavesurfer.on('timeupdate', (currentTime) => curLbl.textContent = formatTime(currentTime));
        wavesurfer.on('play', () => { playBtn.innerHTML = '‚è∏'; playBtn.setAttribute('aria-label', 'Pause'); card.classList.add('ring-2', 'ring-blue-500', 'bg-gray-700/50'); });
        wavesurfer.on('pause', () => { playBtn.innerHTML = '‚ñ∂'; playBtn.setAttribute('aria-label', 'Play'); card.classList.remove('ring-2', 'ring-blue-500', 'bg-gray-700/50'); });
        wavesurfer.on('finish', () => wavesurfer.emit('pause'));

        playBtn.addEventListener('click', () => {
            if (wavesurfer.isPlaying()) { wavesurfer.pause(); return; }
            const currentTime = wavesurfer.getCurrentTime();
            const duration = wavesurfer.getDuration();
            if (currentTime > 0 && currentTime < duration) { wavesurfer.play(); return; }
            const startSeconds = parseFloat(startTimeInput.value) || 0;
            wavesurfer.seekTo(startSeconds > 0 && duration > 0 ? (startSeconds / duration) : 0);
            if (fadeInToggle.input.checked && fadeInTime > 0) {
                const targetVolume = parseFloat(volumeSlider.value);
                wavesurfer.setVolume(0);
                wavesurfer.play();
                let start = null;
                const fade = (ts) => {
                    if (!start) start = ts;
                    const progress = Math.min(1, (ts - start) / (fadeInTime * 1000));
                    wavesurfer.setVolume(targetVolume * progress);
                    if (progress < 1) requestAnimationFrame(fade);
                };
                requestAnimationFrame(fade);
            } else {
                wavesurfer.setVolume(parseFloat(volumeSlider.value));
                wavesurfer.play();
            }
        });

        stopBtn.addEventListener('click', () => {
            if (fadeOutToggle.input.checked && wavesurfer.isPlaying()) {
                const currentVolume = wavesurfer.getVolume(); let start;
                const fade = (ts) => {
                    if (!start) start = ts;
                    const progress = Math.max(0, 1 - ((ts - start) / (fadeOutTime * 1000)));
                    wavesurfer.setVolume(currentVolume * progress);
                    if (progress > 0) requestAnimationFrame(fade);
                    else { wavesurfer.stop(); wavesurfer.setVolume(currentVolume); }
                };
                requestAnimationFrame(fade);
            } else { wavesurfer.stop(); }
        });

        const saveSoundData = (key, value) => {
            if (card.dataset.idbKey) {
                idb.get(SOUNDS_STORE, card.dataset.idbKey).then(rec => {
                    if(rec) { rec[key] = value; idb.set(SOUNDS_STORE, card.dataset.idbKey, rec); }
                });
            }
        };
        volumeSlider.addEventListener('input', (e) => wavesurfer.setVolume(e.target.value));
        volumeSlider.addEventListener('change', (e) => saveSoundData('volume', parseFloat(e.target.value)));
        startTimeInput.addEventListener('change', (e) => saveSoundData('startTime', parseFloat(e.target.value)));
    } else {
        card.dataset.text = text; card.dataset.voice = voiceName;
        playBtn.addEventListener('click', () => {
            if (!('speechSynthesis' in window)) return showMessage("Browser TTS is not supported.");
            window.speechSynthesis.cancel();
            const u = new SpeechSynthesisUtterance(text);
            u.voice = window.speechSynthesis.getVoices().find(v => v.name === voiceName);
            u.onstart = () => card.classList.add('ring-2', 'ring-blue-500', 'bg-gray-700/50');
            u.onend = () => { card.classList.remove('ring-2', 'ring-blue-500', 'bg-gray-700/50'); activeUtterances.delete(u); };
            window.speechSynthesis.speak(u); activeUtterances.add(u);
        });
        stopBtn.addEventListener('click', () => { if ('speechSynthesis' in window) window.speechSynthesis.cancel(); });
    }

    delBtn.addEventListener('click', () => {
        if (!confirm('Are you sure you want to delete this sound?')) return;
        if (card.dataset.type === 'audio') {
            const ws = activeAudios.get(card); if (ws) { ws.destroy(); activeAudios.delete(card); }
        } else { window.speechSynthesis.cancel(); }
        card.remove(); updateSectionCount(card.closest('section').dataset.sectionId);
        if (card.dataset.idbKey) idb.delete(SOUNDS_STORE, card.dataset.idbKey);
    });

    editBtn.addEventListener('click', () => {
        const newName = prompt('Enter a new name:', titleEl.textContent);
        if (newName && newName.trim()) {
            const finalName = newName.trim();
            titleEl.textContent = finalName; titleEl.title = finalName;
            if (card.dataset.idbKey) {
                 idb.get(SOUNDS_STORE, card.dataset.idbKey).then(rec => {
                    if(rec) { rec.name = finalName; idb.set(SOUNDS_STORE, card.dataset.idbKey, rec); }
                });
            }
        }
    });

    card.addEventListener('dragstart', (e) => { card.classList.add('dragging'); e.dataTransfer.effectAllowed = 'move'; });
    card.addEventListener('dragend', () => card.classList.remove('dragging'));

    return card;
  };

  const updateSectionCount = (sectionId) => {
    const sectionEl = $(`[data-section-id="${sectionId}"]`);
    if(sectionEl) {
        const count = sectionEl.querySelectorAll('.sound-card').length;
        $('.section-count', sectionEl).textContent = count;
        $('.drop-zone', sectionEl).classList.toggle('has-items', count > 0);
    }
  };


  // ===================================================================
  // D. SECTION MANAGEMENT
  // ===================================================================

  const renderSections = () => {
      soundboardGrid.innerHTML = ''; // Clear existing sections
      sections.forEach(sectionData => {
          const sectionEl = document.createElement('section');
          sectionEl.dataset.sectionId = sectionData.id;

          const header = document.createElement('div');
          header.className = 'flex items-center justify-between mb-2';

          const titleWrap = document.createElement('div');
          titleWrap.className = 'flex items-center gap-2 text-lg font-semibold';
          titleWrap.innerHTML = `
            <h2 class="section-title" contenteditable="true">${sectionData.name}</h2>
            <span class="section-count text-xs bg-gray-700 px-2 py-0.5 rounded-md">0</span>`;

          const deleteBtn = document.createElement('button');
          deleteBtn.className = 'text-gray-400 hover:text-red-400 transition-colors text-lg';
          deleteBtn.innerHTML = '‚úñ';
          deleteBtn.title = 'Delete Section';

          header.append(titleWrap, deleteBtn);

          const dropZone = document.createElement('div');
          dropZone.className = 'drop-zone relative p-4 border-2 border-dashed border-gray-700 rounded-2xl bg-gray-800/50';
          dropZone.innerHTML = `
            <div class="drop-area pointer-events-none absolute inset-0 flex flex-col items-center justify-center text-gray-400">
              <div class="text-3xl">Ôºã</div>
              <div>Drop sounds here or click to import</div>
            </div>`;

          // FIXED: Add footer with "Add Sound" button
          const footer = document.createElement('footer');
          footer.className = 'mt-4';
          const addSoundBtn = document.createElement('button');
          addSoundBtn.className = 'add-sound-btn w-full bg-gray-700 hover:bg-gray-600 text-gray-300 font-semibold py-3 rounded-xl transition-colors active:scale-95';
          addSoundBtn.textContent = 'Ôºã Add Sound / Import';
          footer.appendChild(addSoundBtn);

          const fileInput = document.createElement('input');
          fileInput.type = 'file';
          fileInput.accept = 'audio/*';
          fileInput.multiple = true;
          fileInput.className = 'hidden';

          sectionEl.append(header, dropZone, footer, fileInput);
          soundboardGrid.appendChild(sectionEl);

          // Event Listeners for the new section
          $('.section-title', header).addEventListener('blur', (e) => {
              const newName = e.target.textContent.trim();
              if (newName) {
                const sec = sections.find(s => s.id === sectionData.id);
                if(sec) { sec.name = newName; idb.set(SECTIONS_STORE, 'layout', sections); }
              } else {
                  e.target.textContent = sectionData.name; // Revert if empty
              }
          });

          deleteBtn.addEventListener('click', async () => {
              if (confirm(`Are you sure you want to delete the "${sectionData.name}" section and all its sounds?`)) {
                  // Delete sounds associated with this section
                  const allSounds = await idb.getAll(SOUNDS_STORE);
                  const soundsToDelete = allSounds.filter(s => s.sectionId === sectionData.id);
                  for (const sound of soundsToDelete) {
                      await idb.delete(SOUNDS_STORE, sound.idbKey);
                  }
                  // Remove section from state and save
                  sections = sections.filter(s => s.id !== sectionData.id);
                  await idb.set(SECTIONS_STORE, 'layout', sections);
                  await reRenderBoard(); // Safely re-render the entire board
              }
          });

          // FIXED: Make drop zone AND add button trigger the file input
          addSoundBtn.addEventListener('click', () => fileInput.click());
          dropZone.addEventListener('click', (e) => {
              if (!e.target.closest('.sound-card')) fileInput.click();
          });

          fileInput.addEventListener('change', (e) => {
              if (e.target.files.length) {
                  addFilesToSection(e.target.files, sectionData.id);
                  fileInput.value = '';
              }
          });

          // Drag and Drop
          dropZone.addEventListener('dragenter', e => e.preventDefault());
          dropZone.addEventListener('dragover', e => {
            e.preventDefault();
            const draggingCard = $('.dragging');
            if (draggingCard) {
              const afterElement = getDragAfterElement(dropZone, e.clientY);
              dropZone.insertBefore(draggingCard, afterElement);
            } else { dropZone.classList.add('drag-over'); }
          });
          dropZone.addEventListener('dragleave', () => dropZone.classList.remove('drag-over'));
          dropZone.addEventListener('drop', async (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            const draggingCard = $('.dragging');
            if (draggingCard) {
                const oldSectionId = draggingCard.closest('section').dataset.sectionId;
                updateSectionCount(oldSectionId);
                updateSectionCount(sectionData.id);
                if (draggingCard.dataset.idbKey) {
                    const sound = await idb.get(SOUNDS_STORE, draggingCard.dataset.idbKey);
                    if(sound) {
                        sound.sectionId = sectionData.id;
                        await idb.set(SOUNDS_STORE, draggingCard.dataset.idbKey, sound);
                    }
                }
            } else if (e.dataTransfer.files.length) {
              await addFilesToSection(e.dataTransfer.files, sectionData.id);
            }
          });
      });
  };

  const handleAddSection = async () => {
    const newSection = {
        id: `sec_${Date.now()}`,
        name: 'New Section'
    };
    sections.push(newSection);
    await idb.set(SECTIONS_STORE, 'layout', sections);
    await reRenderBoard(); // Safely re-render the entire board
  };

  // FIXED: New function to safely re-render the entire board state
  const reRenderBoard = async () => {
      // 1. Clean up existing WaveSurfer instances to prevent memory leaks
      activeAudios.forEach(ws => {
          if (ws && typeof ws.destroy === 'function') {
              ws.destroy();
          }
      });
      activeAudios.clear();

      // 2. Render the section containers from state
      renderSections();

      // 3. Re-populate the sections with sounds from the database
      await restoreSounds();
  }


  // ===================================================================
  // E. DATA & FILE HANDLING
  // ===================================================================

  const addFilesToSection = async (files, sectionId) => {
    const sectionEl = $(`[data-section-id="${sectionId}"] .drop-zone`);
    if(!sectionEl) {
        showMessage("Could not find the target section.");
        return;
    }
    for (const file of files) {
      if (!file.type.startsWith('audio/')) continue;
      try {
        const arrayBuffer = await file.arrayBuffer();
        const blob = new Blob([arrayBuffer], { type: file.type });
        const idbKey = `sound_${Date.now()}_${file.name}`;
        const record = { name: file.name.replace(/\.[^/.]+$/, ''), buffer: arrayBuffer, type: file.type, sectionId, volume: 1.0, startTime: 0, idbKey };
        await idb.set(SOUNDS_STORE, idbKey, record);
        const card = await createCardElement({ ...record, blob });
        sectionEl.appendChild(card);
      } catch (e) {
        showMessage(`Could not process or save the file: ${file.name}`);
      }
    }
    updateSectionCount(sectionId);
  };

  const restoreSounds = async () => {
      try {
          const sounds = await idb.getAll(SOUNDS_STORE);
          for (const soundRec of sounds) {
              const targetSection = $(`[data-section-id="${soundRec.sectionId}"] .drop-zone`);
              if (targetSection) {
                  let card;
                  if (soundRec.type === 'tts') {
                      card = await createCardElement(soundRec);
                  } else {
                      const blob = new Blob([soundRec.buffer], { type: soundRec.type });
                      card = await createCardElement({ ...soundRec, blob });
                  }
                  targetSection.appendChild(card);
              }
          }
          // Update all counts after restoring
          sections.forEach(sec => updateSectionCount(sec.id));
      } catch (e) {
          showMessage("Could not restore saved sounds from the database.");
      }
  };


  // ===================================================================
  // F. FEATURE MODULES (TTS, Recording)
  // ===================================================================

  const populateVoiceList = () => {
    const voices = window.speechSynthesis.getVoices();
    voiceSelect.innerHTML = '<option value="">Select a voice...</option>';
    voices.forEach(voice => {
      const option = document.createElement('option');
      option.value = voice.name;
      option.textContent = `${voice.name} (${voice.lang})`;
      voiceSelect.appendChild(option);
    });
    const lastSelected = localStorage.getItem('lastSelectedVoice');
    if (lastSelected && voices.some(v => v.name === lastSelected)) {
      voiceSelect.value = lastSelected;
    } else if (voices.length > 0) {
      voiceSelect.value = voices[0].name;
    }
  };

  const handleTTSAction = async (action) => {
    const text = ttsText.value.trim();
    const voiceName = voiceSelect.value;
    if (!text) return showMessage("Please enter some text.");
    if (!voiceName) return showMessage("Please select a voice.");

    if (action === 'preview') {
      window.speechSynthesis.cancel();
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.voice = window.speechSynthesis.getVoices().find(v => v.name === voiceName);
      window.speechSynthesis.speak(utterance);
    } else if (action === 'add') {
      if (sections.length === 0) {
        showMessage("Please add a section before adding sounds.");
        return;
      }
      const firstSectionId = sections[0].id;
      const targetSectionEl = $(`[data-section-id="${firstSectionId}"] .drop-zone`);
      const idbKey = `tts_${Date.now()}`;
      const cardData = { name: text, text, voiceName, idbKey, type: 'tts', sectionId: firstSectionId };

      try {
        const card = await createCardElement(cardData);
        targetSectionEl.appendChild(card);
        updateSectionCount(firstSectionId);
        await idb.set(SOUNDS_STORE, idbKey, cardData);
      } catch (e) { showMessage("Could not create the TTS sound card."); }
    }
  };

  const getMicrophoneStream = async () => {
    if (microphoneStream) return microphoneStream;
    try {
      microphoneStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      return microphoneStream;
    } catch (err) {
      showMessage("Microphone access denied. Please enable it in your browser settings.");
      return null;
    }
  };

  const startRecording = async () => {
    if (isRecording) return;
    const stream = await getMicrophoneStream();
    if (!stream) return;
    try {
      mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
    } catch (e) { return showMessage('Recording is not supported on this browser.'); }
    audioChunks = [];
    mediaRecorder.ondataavailable = e => e.data.size > 0 && audioChunks.push(e.data);
    mediaRecorder.onstop = async () => {
        if (sections.length === 0) {
            showMessage("Please add a section before saving a recording.");
            return;
        }
        const firstSectionId = sections[0].id;
        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
        const fileName = `Recording_${Date.now()}.webm`;
        await addFilesToSection([new File([audioBlob], fileName, { type: 'audio/webm' })], firstSectionId);
    };
    mediaRecorder.start();
    isRecording = true;
    recordBtn.classList.add('recording-pulse');
    recordBtn.innerHTML = 'üî¥';
    recordingTooltip.textContent = 'Release to save';
    recordingTooltip.style.opacity = '1';
  };

  const stopRecording = () => {
    if (!isRecording || !mediaRecorder) return;
    mediaRecorder.stop();
    isRecording = false;
    recordBtn.classList.remove('recording-pulse');
    recordBtn.innerHTML = 'üéôÔ∏è';
    recordingTooltip.textContent = 'Hold to record';
    recordingTooltip.style.opacity = '0';
  };


  // ===================================================================
  // G. EVENT LISTENERS & INITIALIZATION
  // ===================================================================

  const initializeEventListeners = () => {
    // Global Controls
    fadeInSlider.addEventListener('input', e => { fadeInTime = parseFloat(e.target.value); fadeInVal.textContent = fadeInTime.toFixed(1); saveSettings(); });
    fadeOutSlider.addEventListener('input', e => { fadeOutTime = parseFloat(e.target.value); fadeOutVal.textContent = fadeOutTime.toFixed(1); saveSettings(); });
    fadeAllBtn.addEventListener('click', () => { window.speechSynthesis.cancel(); activeAudios.forEach((ws, card) => card.querySelector('.btn-stop')?.click()); });
    helpBtn.addEventListener('click', () => helpModal.classList.add('visible'));
    addSectionBtn.addEventListener('click', handleAddSection);

    // Modals
    alertModalCloseBtn.addEventListener('click', () => alertModal.classList.remove('visible'));
    helpModalCloseBtn.addEventListener('click', () => helpModal.classList.remove('visible'));
    helpModal.addEventListener('click', (e) => { if (e.target === helpModal) helpModal.classList.remove('visible'); });

    // TTS & Recording
    previewBtn.addEventListener('click', () => handleTTSAction('preview'));
    generateBtn.addEventListener('click', () => handleTTSAction('add'));
    voiceSelect.addEventListener('change', () => localStorage.setItem('lastSelectedVoice', voiceSelect.value));
    if (speechSynthesis.onvoiceschanged !== undefined) {
      speechSynthesis.onvoiceschanged = populateVoiceList;
    }
    recordBtn.addEventListener('pointerdown', startRecording);
    recordBtn.addEventListener('pointerup', stopRecording);
    recordBtn.addEventListener('pointerleave', stopRecording);
  };

  const getDragAfterElement = (container, y) => {
    const draggableElements = [...container.querySelectorAll('.sound-card:not(.dragging)')];
    return draggableElements.reduce((closest, child) => {
      const box = child.getBoundingClientRect();
      const offset = y - box.top - box.height / 2;
      return (offset < 0 && offset > closest.offset) ? { offset, element: child } : closest;
    }, { offset: Number.NEGATIVE_INFINITY }).element;
  };

  const initializeApp = async () => {
    const settings = loadSettings();
    fadeInTime = settings.fadeIn ?? 2.0;
    fadeOutTime = settings.fadeOut ?? 2.0;
    fadeInSlider.value = fadeInTime;
    fadeOutSlider.value = fadeOutTime;
    fadeInVal.textContent = fadeInTime.toFixed(1);
    fadeOutVal.textContent = fadeOutTime.toFixed(1);

    document.querySelectorAll('#donationLinks img').forEach(img => img.addEventListener('error', () => { img.style.display = 'none'; }));

    populateVoiceList();
    initializeEventListeners();

    // Load layout, or create a default one
    const savedSections = await idb.get(SECTIONS_STORE, 'layout');
    if (savedSections && savedSections.length > 0) {
        sections = savedSections;
    } else {
        // Create a default initial section
        sections = [{ id: `sec_${Date.now()}`, name: 'Sounds' }];
        await idb.set(SECTIONS_STORE, 'layout', sections);
    }

    renderSections();
    await restoreSounds();

    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('./service-worker.js').catch(err => {
        console.error('Service Worker registration failed:', err);
      });
    }
  };

  initializeApp();
});
</script>
</body>
</html>